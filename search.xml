<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-Class</title>
    <url>/2020/11/25/ES6-Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h4 id="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"><a href="#由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。" class="headerlink" title="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"></a>由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。</h4><blockquote>
<p>ES5生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">p.sayname();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,p.age);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020112510551285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>ES6生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">//相当于构造函数内部</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//相当于prototype</span></span><br><span class="line">   <span class="function"><span class="title">sayname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201125105223617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用static声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line">	<span class="keyword">static</span> age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,Person.name,Person.age);</span><br><span class="line"><span class="comment">//undefined &quot;hxh&quot; 18</span></span><br><span class="line"><span class="comment">//不使用static声明</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">class Person&#123;</span></span><br><span class="line"><span class="string">name = &#x27;hxh&#x27;;</span></span><br><span class="line"><span class="string">    age = 18;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let p = new Person();</span></span><br><span class="line"><span class="string">console.log(p.name,Person.name,Person.age);</span></span><br><span class="line"><span class="string">//hxh Person undefined  </span></span><br><span class="line"><span class="string">//其中Person.name是显示其自身的函数名与内部的name属性无关</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>ES5构造函数继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">name,size</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">&#125;<span class="comment">//父级方法</span></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;<span class="comment">//父级原型上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sphone</span>(<span class="params">name,size,effect</span>) </span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>,name,size);</span><br><span class="line">    <span class="built_in">this</span>.effect = effect;</span><br><span class="line">&#125;<span class="comment">//子级继承父级的方法属性  </span></span><br><span class="line">Sphone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line">Sphone.prototype.constructor = Sphone;</span><br><span class="line">Sphone.prototype.app = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">&#125;<span class="comment">//子级私有方法</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">1200</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126090011498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>ES6类的继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name,size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;  <span class="comment">//使用extends关键字继承方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,size,effect</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,size);<span class="comment">//使用super关键字调用</span></span><br><span class="line">        <span class="built_in">this</span>.effect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">app</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">40</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126100454582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>ES6-Promise</title>
    <url>/2020/11/23/ES6-Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promsie"><a href="#Promsie" class="headerlink" title="Promsie"></a>Promsie</h1><p><strong>是异步编程的一种解决方案（其他的解决方式还有回调函数，监听，发布/订阅等）</strong></p>
<h1 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h1><p>使用构造函数来创建一个promise对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Promsie这个构造函数会把一个处理器函数(excutor)作为自己的参数 这个函数接收resolve，reject两个函数作为参数。<br>说明：excutor会在Promise内部立即执行，异步操作会在执行器执行<br>当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因时，会调用reject 函数。<br>状态：pedding–&gt;resolved    pedding–&gt;rejected<br>注：error属于失败<br><img src="https://img-blog.csdnimg.cn/20201130214548640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="error"></p>
<p><img src="https://img-blog.csdnimg.cn/20201130210334769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="promise"><br>例如在下面情境下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Promise(function(resolve, reject)&#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;C:/Users/14828/Desktop/代码/ES6/ES6_Promise/resources/为学.md&quot;</span>, (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码是在node环境中  利用promise封装读取文件内容<br>如果出现错误则调用reject函数  并传入错误信息  反之调用resolve函数  并传入数据。</p>
<h1 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h1><p>可以使用promise.then()，promise.catch() promise.finally()方法来进行进一步的操作。（将进一步的操作与一个变为已确定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象）</p>
<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ES6-模块化</title>
    <url>/2020/11/26/ES6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
</blockquote>
<h1 id="模块功能命令"><a href="#模块功能命令" class="headerlink" title="模块功能命令"></a>模块功能命令</h1><h3 id="一-export命令"><a href="#一-export命令" class="headerlink" title="一. export命令"></a>一.<font color="blue"> export</font>命令</h3><blockquote>
<p>export命令用于规定模块的对外接口。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
</blockquote>
<h6 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h6><ol>
<li>在变量/函数声明前添加<font color="red"> export</font></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在脚本末尾用大括号括起来，优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;</span><br><span class="line">    name,n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二-import命令"><a href="#二-import命令" class="headerlink" title="二. import命令"></a>二.<font color="blue"> import</font>命令</h3><blockquote>
<p>import命令用于输入其他模块提供的功能。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>ES6-Set与Map集合</title>
    <url>/2020/11/25/ES6-Set%E4%B8%8EMap%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-Set"><a href="#一-Set" class="headerlink" title="一.Set"></a>一.Set</h1><h2 id="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"><a href="#ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。" class="headerlink" title="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"></a>ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125084002138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以看到Set会返回给你一组不重复的值，且在Set的原型上保存了一些方法和属性。</p>
<blockquote>
<ol>
<li>size属性<br>size内保存的是Set对象内部的长度</li>
<li>add()方法<br>使用add()方法可以为Set添加成员  但如果添加的成员在Set内已经存在，则不会添加。</li>
<li>has()方法<br>使用has()方法传入参数来检测Set内部是否含有该成员  </li>
<li>delete()方法<br>使用delete()方法删除目标成员，Set内部如果有则删除并返回true，反之返回false</li>
<li>clear()方法<br>使用clear()方法清空Set内部的所有成员</li>
<li>entries()方法<br>返回一个迭代器对象iterator   因此也可以使用for…of来遍历Set对象<br><img src="https://img-blog.csdnimg.cn/20201125091343969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></li>
</ol>
</blockquote>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><blockquote>
<ol>
<li>使用Set与扩展运算符…来进行数组去重。</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr = [...new <span class="built_in">Set</span>(arr)]);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>使用Set实现交集，并集，补集</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1,...arr2]);</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(new1);<span class="comment">//[3]</span></span><br><span class="line"><span class="comment">//交集的补集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = [...arr1,...arr2];</span><br><span class="line">newarr = <span class="keyword">new</span> <span class="built_in">Set</span>(newarr);</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> new1) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newarr.has(v))&#123;</span><br><span class="line">        newarr.delete(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,4,5]</span></span><br></pre></td></tr></table></figure>
<h1 id="二-Map"><a href="#二-Map" class="headerlink" title="二.Map"></a>二.Map</h1><p><strong>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;惠新浩&#x27;</span>);</span><br><span class="line">m.set(<span class="string">&#x27;change&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;change&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125095306585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>set()<br>使用set方法为Map对象添加键值对 其允许传入两个参数（键名，键值）。</li>
<li>get()<br>使用get方法读取键名所对应的键值。</li>
<li>其余方法类似于Set</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JQuery与DOM对象</title>
    <url>/2020/12/14/JQuery%E5%AF%B9%E8%B1%A1%E4%B8%8EDOM%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-什么是DOM对象"><a href="#一-什么是DOM对象" class="headerlink" title="一.什么是DOM对象"></a>一.什么是DOM对象</h2><blockquote>
<h4>文档对象模型简称DOM，是W3C组织推荐的处理可扩展置标语言的标准编程接口。</h4>
</blockquote>
<ul>
<li>DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。</li>
<li>通过DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的
</li><li>内容进行修改和删除，同时也可以创建新的元素。</li>
<li>DOM 独立于平台和编程语言。它可被任何编程语言诸如 Java、JavaScript 和
VBScript 使用。</li>
<li>DOM对象，即是我们用传统的方法(javascript)获得的对象。</li>
<li>DOM准确说是对文档对象的一种规范标准(文档对象模型),标准只定义了属性和方法行为。</li>

<h2 id="二-什么是JQuery对象"><a href="#二-什么是JQuery对象" class="headerlink" title="二.什么是JQuery对象"></a>二.什么是JQuery对象</h2><blockquote>
<h4>就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的，其可以使用jQuery里的方法。但是不能使用DOM的方法;反过来DOM对象也不能使用</h4>
</blockquote>
<ul>
<li>jQuery对象属于类数组对象，可以通过它的toArray方法转换成数组.</li>
<li>虽然jquery对象是包装DOM对象产生的对象，但是他不能使用DOM对象的方法。如
$("#test").innerHTML、document.getElementById("id").html().</li>

<h2 id="三-相互转换"><a href="#三-相互转换" class="headerlink" title="三.相互转换"></a>三.相互转换</h2><pre><code>1.jquery转dom
        因为他是一个类数组对象，可以使用jquery[index]获取数组中保存的dom对象
        也可以使用jquery中的get方法。当get方法不传参时，会将jquery转换成数组。
2.dom转jquery
        将dom对象放入jquery的入口函数内部，就会将该dom元素转换为一个jquery对象    $()。</code></pre>
</ul></ul>]]></content>
  </entry>
  <entry>
    <title>JQuery与DOM对象</title>
    <url>/2021/02/02/%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-软件架构模式"><a href="#一-软件架构模式" class="headerlink" title="一.软件架构模式"></a>一.软件架构模式</h1><h2 id="MVC模式简介"><a href="#MVC模式简介" class="headerlink" title="MVC模式简介"></a>MVC模式简介</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="img"></p>
<p>M–&gt;model–&gt;负责储存数据–&gt;对象，数组等变量</p>
<p>V–&gt;view–&gt;用户所看到的界面(html,css)</p>
<p>C–&gt;controller–&gt;业务逻辑（事件交互  如何根据视图与用户的交互改变数据–&gt;操作DOM对象进行事件的绑定）</p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<p>eg: Backbone.JS</p>
<ol>
<li><p>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p>
</li>
<li><p>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p>
</li>
<li><p>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p>
</li>
</ol>
<h2 id="MVP模式简介"><a href="#MVP模式简介" class="headerlink" title="MVP模式简介"></a>MVP模式简介</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt="img"></p>
<p>M–&gt;model–&gt;负责储存数据–&gt;对象，数据等变量</p>
<p>V–&gt;view–&gt;用户所看到的界面(html,css)</p>
<p>P–&gt;presenter–&gt; 包含着组件的事件处理，负责检索 Model 获取资料，和将获取的资料经过格式转换与 View 进行沟通。 </p>
<ol>
<li><p>各部分之间的通信，都是双向的。</p>
</li>
<li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p>
</li>
<li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p>
</li>
</ol>
<h2 id="MVVM模式简介"><a href="#MVVM模式简介" class="headerlink" title="MVVM模式简介"></a>MVVM模式简介</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p> 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Vue和Angular都采用这种模式。 </p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="img"></p>
<h1 id="二-VUE使用"><a href="#二-VUE使用" class="headerlink" title="二.VUE使用"></a>二.VUE使用</h1><h2 id="1-条件渲染"><a href="#1-条件渲染" class="headerlink" title="1.条件渲染"></a>1.条件渲染</h2><pre><code>1.v-if  --&gt;如果值为false则目标不会被渲染到页面上 若已经渲染到DOM上，则会从DOM中去除

2.v-show --&gt;display：none  会渲染到DOM上</code></pre>
<h2 id="2-列表渲染"><a href="#2-列表渲染" class="headerlink" title="2.列表渲染"></a>2.列表渲染</h2><pre><code>v-for 添加key属性可以使被渲染出的元素具有唯一性</code></pre>
<h2 id="3-模板语法"><a href="#3-模板语法" class="headerlink" title="3.模板语法"></a>3.模板语法</h2><pre><code>形如 &#123;&#123; H?a:b &#125;&#125; 可在其中添加简单的三元运算符</code></pre>
<h2 id="4-计算属性"><a href="#4-计算属性" class="headerlink" title="4.计算属性"></a>4.计算属性</h2><pre><code>在computed对象内定义计算规则并在view中调用 会将计算的结果保存  只要参数内容不修改,会调用保存的结果而不会重新计算</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Original message: <span class="string">&quot;&#123;&#123; message &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: <span class="string">&quot;&#123;&#123; reversedMessage &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-侦听属性"><a href="#5-侦听属性" class="headerlink" title="5.侦听属性"></a>5.侦听属性</h2><pre><code>在watch对象中定义需要监听数据的函数 数据改变就会执行该函数
watch对象中  对象的键名是要监听的数据变量名 键值是要执行的函数</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">	arr:<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(val)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-表单输入绑定"><a href="#6-表单输入绑定" class="headerlink" title="6.表单输入绑定"></a>6.表单输入绑定</h2><pre><code>使用v-model进行对数据进行双向数据绑定 修饰符……</code></pre>
<h2 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h2><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<h3 id="什么是vue生命周期？"><a href="#什么是vue生命周期？" class="headerlink" title="什么是vue生命周期？"></a>什么是vue生命周期？</h3><ul>
<li>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。在整个Vue实例的生命周期中会执行这些钩子函数<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3></li>
<li>实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据<h3 id="beforeCreate与created之间"><a href="#beforeCreate与created之间" class="headerlink" title="beforeCreate与created之间"></a>beforeCreate与created之间</h3></li>
<li>在beforeCreate与created之间进行初始化事件,数据的观测 绑定data数据，methods方法等<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3></li>
<li>实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到$el属性。$ref属性内容为空数组 <h3 id="created与beforeMount之间"><a href="#created与beforeMount之间" class="headerlink" title="created与beforeMount之间"></a>created与beforeMount之间</h3></li>
<li>首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)—–如果我们在后面继续调用vm.$mount(el),(挂载dom节点)可以发现代码继续向下执行了<br>接下–&gt;template参数选项的有无对生命周期的影响。<br>（1）.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（2）.如果没有template选项，则将外部HTML作为模板编译。<br>（3）.可以看到template中的模板优先级要高于outer HTML的优先级<br>修改代码如下, 在HTML结构中增加了一串html，在vue对象中增加了template选项： 可以发现template中的内容会覆盖outer HTML中的内容<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!--html中修改的--&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;message + <span class="string">&#x27;这是在outer HTML中的&#x27;</span>&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">&quot;&lt;h1&gt;&#123;&#123;message +&#x27;这是在template中的&#x27;&#125;&#125;&lt;/h1&gt;&quot;</span>, <span class="comment">//在vue配置项中修改的</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;Vue的生命周期&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
这下就可以想想什么el的判断要在template之前了~是因为vue需要通过el找到对应的outer template。<br>在vue对象中还有一个render函数(渲染函数)，它是以createElement作为参数，然后做渲染操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;this is 	createElement&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到页面中渲染的为this is createElement<br>因此优先级为render函数选项 &gt; template选项 &gt; outer HTML</p>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p>在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数  给Vue实例添加$el成员   此时的this.$el就是一个    DOM对象  但可以发现，此时 h1中还是通进行占位 因为此时还未挂载到页面上   此时仍是虚拟DOM的形式存在 </p>
<p><img src="/2021/02/02/%E6%A6%82%E5%BF%B5/Users\14828\AppData\Roaming\Typora\typora-user-images\1612433875946.png"></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问  h1处不再是用占位。</p>
<p><img src="/2021/02/02/%E6%A6%82%E5%BF%B5/Users\14828\AppData\Roaming\Typora\typora-user-images\1612434167966.png"></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li>响应式数据更新时调用，发生在虚拟DOM打补丁之前 </li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li>虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li>实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p>实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 </p>
<h2 id="8-组件基础"><a href="#8-组件基础" class="headerlink" title="8.组件基础"></a>8.组件基础</h2><h3 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h3><p>调用Vue对象的component方法传入自定义组件名称，以及模板等,与根组件唯一区别是无el挂载点。之后就可以在html中通过<hello></hello>形式调用组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">    <span class="string">&#x27;hello&#x27;</span>:Vue.component(<span class="string">&#x27;hello&#x27;</span>,&#123;</span><br><span class="line">        template:<span class="string">&#x27;&lt;h1 @click=&quot;change&quot;&gt;&#123;&#123;hxh&#125;&#125;&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                hxh:<span class="string">&#x27;hello 浩哥&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.hxh = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="组件间通信-props"><a href="#组件间通信-props" class="headerlink" title="组件间通信(props)"></a>组件间通信(props)</h3><h4 id="1-父子组件"><a href="#1-父子组件" class="headerlink" title="1.父子组件"></a>1.父子组件</h4><pre><code>1&gt;父传子
在子组件中添加props数组  存放与父组件通信的属性名称 父组件可以把内容通过在props中添加的属性传入子组件中</code></pre>
<p>  <strong>如果传给子组件的是一个方法，子组件也可以调用该方法。其中父组件方法的this指向父组件，而不是调用的组件。因此子组件调用该方法也可以操作父组件</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:title</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">也可以=&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">hello</span> <span class="attr">title</span>=<span class="string">&#x27;ruarua&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    name:ruarua</span><br><span class="line">&#125;</span><br><span class="line">components:&#123;</span><br><span class="line"> <span class="string">&#x27;hello&#x27;</span>:Vue.component(<span class="string">&#x27;hello&#x27;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">    template:<span class="string">&#x27;&lt;h1 @click=&quot;change&quot;&gt;&#123;&#123;hxh+title&#125;&#125;&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">          hxh:<span class="string">&#x27;hello 浩哥&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还可以使用更简单的方法来操作</strong>  如果在子组件打印this就会发现，this身上绑定了一个$parent属性，你会发现this.$parent === app.因此可以这样**@click=’$parent.show(item)’**<br><strong>但是为了降低耦合不建议这样操作</strong><br>    2&gt;子传父</p>
<p>  使用$emit方法将子组件的值抛出(<strong>this.$emit(‘foodshow’,data)</strong>),这个方法接收两个参数–&gt;(‘自定义参数’,‘要抛出的变量’)   在父组件使用组件的位置用自定义事件接收  作为函数的一个参数传入方法中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">food</span> <span class="attr">name</span>=<span class="string">&#x27;water&#x27;</span> @<span class="attr">foodshow</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;food&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line"> <span class="string">&#x27;food&#x27;</span>:Vue.component(<span class="string">&#x27;food&#x27;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    template:<span class="string">`&lt;div&gt;&lt;h1 v-for=&#x27;item in foods&#x27; @click=&#x27;show(item)&#x27;&gt;&#123;&#123;name&#125;&#125;:&#123;&#123;item&#125;&#125;&lt;/h1&gt;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         foods:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      show:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;foodshow&#x27;</span>,data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，在父组件中有一个$children <strong>但是为了降低耦合不建议这样操作</strong></p>
<h4 id="2-兄弟组件"><a href="#2-兄弟组件" class="headerlink" title="2.兄弟组件"></a>2.兄弟组件</h4><h3 id="组件上使用v-model"><a href="#组件上使用v-model" class="headerlink" title="组件上使用v-model"></a>组件上使用v-model</h3><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/11/30/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="函数对象-实例对象"><a href="#函数对象-实例对象" class="headerlink" title="函数对象,实例对象"></a>函数对象,实例对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;<span class="comment">//Fn函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn();<span class="comment">//此时Fn叫做构造函数 </span></span><br><span class="line">                <span class="comment">//f是Fn构造出来的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.bind());<span class="comment">//通过.来调用Funciton原型上的属性或方法</span></span><br><span class="line">                        <span class="comment">//叫做函数对象</span></span><br></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);<span class="comment">//不进入回调队列</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);<span class="comment">//这个函数进入回调队列排队</span></span><br><span class="line">    <span class="comment">//回调队列：JS在运行时候，有一个列表用于记录将要处理的回调事件。遵循FIFO（先进先出）原则。</span></span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;,,,&#x27;</span>);</span><br><span class="line"><span class="comment">//，，，</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><p>当所有promise对象都成功时返回一个promise数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213637729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all resolved"><br>只要有一个不成功则返回失败的reason</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213813769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all rejected"></p>
<h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><p>race返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130214412804.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol>
<li>error属于promise的rejected状态</li>
<li>当一个promise指定了多个成功/失败的函数时，promise改变成哪个状态就调用哪个状态的函数。</li>
<li>状态改变与指定回调函数的先后次序<br>1&gt;先指定回调函数，则需要将当前指定的回调函数保存起来， 后改变状态，同时指定数据。<br>2&gt;先改变状态，后指定回调函数，异步执行回调函数。</li>
<li> promise.then()方法返回新的promise的结果<br>1&gt;抛出错误 返回rejected reason就是抛出的错误<br>2&gt;返回非promise结果    返回resolved<br>3&gt;返回新的promise 外部promise的状态由内部promise的状态决定。</li>
<li>promsie如何串联多个操作任务？<br>promise的then方法返回一个promise对象，可以通过对then方法的链式调用串联多个任务。</li>
<li>promsie值穿透<br>如下代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);<span class="comment">//foo</span></span><br></pre></td></tr></table></figure>
如果给then传入的是非函数的值，相当于传入的是null</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin().then(functiuoin () &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>中断promise链<br>当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获。利用这个特性能跳过链中函数的调用，直至链路终点，变相地结束Promise链。然而，若链路中也对错误进行了捕获，则后续的函数可能会继续执行。此时可以返回一个无参数的promsie对象来中断promsie链。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_1]&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;); <span class="comment">// 返回“pending”状态的Promise对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;                   <span class="comment">// 后续的函数不会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_2]&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[catch]&#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// =&gt; [onFulfilled_1]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201204212254565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="思维导图"></p>
<h3 id="函数版本代码"><a href="#函数版本代码" class="headerlink" title="函数版本代码"></a>函数版本代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        _this.promiseState = PENDING;<span class="comment">//promise状态</span></span><br><span class="line">        _this.promiseResult = <span class="literal">undefined</span>;<span class="comment">//promise返回的结果</span></span><br><span class="line">        _this.callbacks = [];<span class="comment">//每个元素的结构==&gt;对象&#123;onresolve()&#123;&#125;,onrejecte()&#123;&#125;&#125;</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//1.将状态改为fulfilled</span></span><br><span class="line">                _this.promiseState = RESOLVED;</span><br><span class="line">                <span class="comment">//2.保存value值</span></span><br><span class="line">                _this.promiseResult = value;</span><br><span class="line">                <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    _this.callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                        obj.onresolve(value);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">                <span class="comment">//1.将状态改为rejected</span></span><br><span class="line">                _this.promiseState = REJECTED;</span><br><span class="line">                <span class="comment">//2.保存reason值</span></span><br><span class="line">                _this.promiseResult = reason;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&quot;Uncaught (in promise)&quot;</span>+reason);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                        obj.onrejected(reason);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行器函数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excutor(resolve,reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的resolve函数  返回一个指定结果为成功的对象</span></span><br><span class="line">    <span class="comment">//其成功的值就是其传入的value值</span></span><br><span class="line">    promise.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                value.then(re,rj)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                re(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的reject函数  返回一个指定结果为失败的对象</span></span><br><span class="line">    <span class="comment">//其失败的值就是其传入的reason值  并抛出错误</span></span><br><span class="line">    promise.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            rj(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的all方法</span></span><br><span class="line">    <span class="comment">//当所有promise对象都成功返回一个数组 数组内是成功的值  当其中某个失败  返回失败的结果</span></span><br><span class="line">    promise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);<span class="comment">//创建一个数组保存成功的value</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">p,index</span>) =&gt;</span> &#123;</span><br><span class="line">                promise.resolve(p).then(</span><br><span class="line">                    value=&gt;&#123;</span><br><span class="line">                        values[index] = value</span><br><span class="line">                        flag++</span><br><span class="line">                        <span class="keyword">if</span>(flag===promises.length)&#123;</span><br><span class="line">                            re(values);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                        rj(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的race方法</span></span><br><span class="line">    <span class="comment">//哪个promise对象先改变状态就返回哪个的值value/reason</span></span><br><span class="line">    promise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                promise.resolve(p).then(</span><br><span class="line">                    value=&gt;&#123;</span><br><span class="line">                        re(value)</span><br><span class="line">                    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                        rj(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数原型对象上的then方法</span></span><br><span class="line">    <span class="comment">//传入两个函数处理成功,失败的结果</span></span><br><span class="line">    promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onresolve,onrejected</span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//指定默认成功的回调   穿透</span></span><br><span class="line">        onresolve = <span class="keyword">typeof</span> onresolve===<span class="string">&#x27;function&#x27;</span> ? onresolve : <span class="function"><span class="params">value</span>=&gt;</span>value;</span><br><span class="line">        <span class="comment">//指定默认失败的回调函数</span></span><br><span class="line">        onrejected = <span class="keyword">typeof</span> onrejected===<span class="string">&#x27;function&#x27;</span> ? onrejected : <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="built_in">console</span>.error(reason); <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">            <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">            <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装处理函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//result 是把成功的值传给then成功的函数 </span></span><br><span class="line">                    <span class="keyword">const</span> result = callback(_this.promiseResult);</span><br><span class="line">                    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                        <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                        result.then(</span><br><span class="line">                            <span class="comment">//value =&gt; resolve(value),当result成功时 then的promise也成功</span></span><br><span class="line">                            <span class="comment">//reason=&gt; reject(reason)当result失败时 then的promise也失败</span></span><br><span class="line">                            resolve,reject</span><br><span class="line">                        )</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState === PENDING)&#123;</span><br><span class="line">                <span class="comment">//如果为pending 将传入的参数保存到callbacks中</span></span><br><span class="line">                _this.callbacks.push(&#123;</span><br><span class="line">                    <span class="function"><span class="title">onresolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                        handle(onresolve)</span><br><span class="line">                    &#125;,<span class="function"><span class="title">onrejected</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">                        handle(onrejected)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);  </span><br><span class="line">                <span class="comment">//如果为resolved 将then方法成功的函数保存</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === RESOLVED)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    handle(onresolve)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//如果为rejected 将传入的参数保存到callbacks中</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === REJECTED)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    handle(onrejected)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数原型对象上的catch方法 处理失败的结果</span></span><br><span class="line">    promise.prototype.Catch = <span class="function"><span class="keyword">function</span> (<span class="params">onrejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onrejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.promise = promise;<span class="comment">//向外暴露promise接口</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="class版本代码"><a href="#class版本代码" class="headerlink" title="class版本代码"></a>class版本代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">promise</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">            _this.promiseState = PENDING;<span class="comment">//promise状态</span></span><br><span class="line">            _this.promiseResult = <span class="literal">undefined</span>;<span class="comment">//promise返回的结果</span></span><br><span class="line">            _this.callbacks = [];<span class="comment">//每个元素的结构==&gt;对象&#123;onresolve()&#123;&#125;,onrejecte()&#123;&#125;&#125;</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//1.将状态改为fulfilled</span></span><br><span class="line">                    _this.promiseState = RESOLVED;</span><br><span class="line">                    <span class="comment">//2.保存value值</span></span><br><span class="line">                    _this.promiseResult = value;</span><br><span class="line">                    <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                    <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        _this.callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                            obj.onresolve(value);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">                    <span class="comment">//1.将状态改为rejected</span></span><br><span class="line">                    _this.promiseState = REJECTED;</span><br><span class="line">                    <span class="comment">//2.保存reason值</span></span><br><span class="line">                    _this.promiseResult = reason;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&quot;Uncaught (in promise)&quot;</span>+reason);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                    <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                            obj.onrejected(reason);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行器函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                excutor(resolve,reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//函数对象的resolve函数  返回一个指定结果为成功的对象</span></span><br><span class="line">        <span class="comment">//其成功的值就是其传入的value值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(value <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                    value.then(re,rj)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    re(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的reject函数  返回一个指定结果为失败的对象</span></span><br><span class="line">        <span class="comment">//其失败的值就是其传入的reason值  并抛出错误</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                rj(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的all方法</span></span><br><span class="line">        <span class="comment">//当所有promise对象都成功返回一个数组 数组内是成功的值  当其中某个失败  返回失败的结果</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);<span class="comment">//创建一个数组保存成功的value</span></span><br><span class="line">            <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                promises.forEach(<span class="function">(<span class="params">p,index</span>) =&gt;</span> &#123;</span><br><span class="line">                    promise.resolve(p).then(</span><br><span class="line">                        value=&gt;&#123;</span><br><span class="line">                            values[index] = value</span><br><span class="line">                            flag++</span><br><span class="line">                            <span class="keyword">if</span>(flag===promises.length)&#123;</span><br><span class="line">                                re(values);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            rj(reason)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的race方法</span></span><br><span class="line">        <span class="comment">//哪个promise对象先改变状态就返回哪个的值value/reason</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                    promise.resolve(p).then(</span><br><span class="line">                        value=&gt;&#123;</span><br><span class="line">                            re(value)</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            rj(reason)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//函数原型对象上的then方法</span></span><br><span class="line">        <span class="comment">//传入两个函数处理成功,失败的结果</span></span><br><span class="line">        <span class="function"><span class="title">then</span>(<span class="params">onresolve,onrejected</span>)</span> &#123;  </span><br><span class="line">            <span class="comment">//指定默认成功的回调   穿透</span></span><br><span class="line">            onresolve = <span class="keyword">typeof</span> onresolve===<span class="string">&#x27;function&#x27;</span> ? onresolve : <span class="function"><span class="params">value</span>=&gt;</span>value;</span><br><span class="line">            <span class="comment">//指定默认失败的回调函数</span></span><br><span class="line">            onrejected = <span class="keyword">typeof</span> onrejected===<span class="string">&#x27;function&#x27;</span> ? onrejected : <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="built_in">console</span>.error(reason); <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">            <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//封装处理函数</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//result 是把成功的值传给then成功的函数 </span></span><br><span class="line">                        <span class="keyword">const</span> result = callback(_this.promiseResult);</span><br><span class="line">                        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                            <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                            result.then(</span><br><span class="line">                                <span class="comment">//value =&gt; resolve(value),当result成功时 then的promise也成功</span></span><br><span class="line">                                <span class="comment">//reason=&gt; reject(reason)当result失败时 then的promise也失败</span></span><br><span class="line">                                resolve,reject</span><br><span class="line">                            )</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState === PENDING)&#123;</span><br><span class="line">                    <span class="comment">//如果为pending 将传入的参数保存到callbacks中</span></span><br><span class="line">                    _this.callbacks.push(&#123;</span><br><span class="line">                        <span class="function"><span class="title">onresolve</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            handle(onresolve)</span><br><span class="line">                        &#125;,<span class="function"><span class="title">onrejected</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            handle(onrejected)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);  </span><br><span class="line">                    <span class="comment">//如果为resolved 将then方法成功的函数保存</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === RESOLVED)&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        handle(onresolve)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//如果为rejected 将传入的参数保存到callbacks中</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === REJECTED)&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        handle(onrejected)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数原型对象上的catch方法 处理失败的结果</span></span><br><span class="line">        <span class="function"><span class="title">Catch</span>(<span class="params">onrejected</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onrejected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.promise = promise;<span class="comment">//向外暴露promise接口</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
