<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-Promise</title>
    <url>/2020/11/23/ES6-Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promsie"><a href="#Promsie" class="headerlink" title="Promsie"></a>Promsie</h1><p><strong>是异步编程的一种解决方案（其他的解决方式还有回调函数，监听，发布/订阅等）</strong></p>
<h1 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h1><p>使用构造函数来创建一个promise对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Promsie这个构造函数会把一个处理器函数(excutor)作为自己的参数 这个函数接收resolve，reject两个函数作为参数。<br>说明：excutor会在Promise内部立即执行，异步操作会在执行器执行<br>当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因时，会调用reject 函数。<br>状态：pedding–&gt;resolved    pedding–&gt;rejected<br>注：error属于失败<br><img src="https://img-blog.csdnimg.cn/20201130214548640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="error"></p>
<p><img src="https://img-blog.csdnimg.cn/20201130210334769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="promise"><br>例如在下面情境下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Promise(function(resolve, reject)&#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;C:/Users/14828/Desktop/代码/ES6/ES6_Promise/resources/为学.md&quot;</span>, (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码是在node环境中  利用promise封装读取文件内容<br>如果出现错误则调用reject函数  并传入错误信息  反之调用resolve函数  并传入数据。</p>
<h1 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h1><p>可以使用promise.then()，promise.catch() promise.finally()方法来进行进一步的操作。（将进一步的操作与一个变为已确定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象）</p>
<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ES6-Class</title>
    <url>/2020/11/25/ES6-Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h4 id="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"><a href="#由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。" class="headerlink" title="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"></a>由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。</h4><blockquote>
<p>ES5生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">p.sayname();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,p.age);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020112510551285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>ES6生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">//相当于构造函数内部</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//相当于prototype</span></span><br><span class="line">   <span class="function"><span class="title">sayname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201125105223617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用static声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line">	<span class="keyword">static</span> age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,Person.name,Person.age);</span><br><span class="line"><span class="comment">//undefined &quot;hxh&quot; 18</span></span><br><span class="line"><span class="comment">//不使用static声明</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">class Person&#123;</span></span><br><span class="line"><span class="string">name = &#x27;hxh&#x27;;</span></span><br><span class="line"><span class="string">    age = 18;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let p = new Person();</span></span><br><span class="line"><span class="string">console.log(p.name,Person.name,Person.age);</span></span><br><span class="line"><span class="string">//hxh Person undefined  </span></span><br><span class="line"><span class="string">//其中Person.name是显示其自身的函数名与内部的name属性无关</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>ES5构造函数继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">name,size</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">&#125;<span class="comment">//父级方法</span></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;<span class="comment">//父级原型上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sphone</span>(<span class="params">name,size,effect</span>) </span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>,name,size);</span><br><span class="line">    <span class="built_in">this</span>.effect = effect;</span><br><span class="line">&#125;<span class="comment">//子级继承父级的方法属性  </span></span><br><span class="line">Sphone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line">Sphone.prototype.constructor = Sphone;</span><br><span class="line">Sphone.prototype.app = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">&#125;<span class="comment">//子级私有方法</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">1200</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126090011498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>ES6类的继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name,size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;  <span class="comment">//使用extends关键字继承方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,size,effect</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,size);<span class="comment">//使用super关键字调用</span></span><br><span class="line">        <span class="built_in">this</span>.effect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">app</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">40</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126100454582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>ES6-Set与Map集合</title>
    <url>/2020/11/25/ES6-Set%E4%B8%8EMap%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-Set"><a href="#一-Set" class="headerlink" title="一.Set"></a>一.Set</h1><h2 id="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"><a href="#ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。" class="headerlink" title="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"></a>ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125084002138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以看到Set会返回给你一组不重复的值，且在Set的原型上保存了一些方法和属性。</p>
<blockquote>
<ol>
<li>size属性<br>size内保存的是Set对象内部的长度</li>
<li>add()方法<br>使用add()方法可以为Set添加成员  但如果添加的成员在Set内已经存在，则不会添加。</li>
<li>has()方法<br>使用has()方法传入参数来检测Set内部是否含有该成员  </li>
<li>delete()方法<br>使用delete()方法删除目标成员，Set内部如果有则删除并返回true，反之返回false</li>
<li>clear()方法<br>使用clear()方法清空Set内部的所有成员</li>
<li>entries()方法<br>返回一个迭代器对象iterator   因此也可以使用for…of来遍历Set对象<br><img src="https://img-blog.csdnimg.cn/20201125091343969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></li>
</ol>
</blockquote>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><blockquote>
<ol>
<li>使用Set与扩展运算符…来进行数组去重。</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr = [...new <span class="built_in">Set</span>(arr)]);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>使用Set实现交集，并集，补集</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1,...arr2]);</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(new1);<span class="comment">//[3]</span></span><br><span class="line"><span class="comment">//交集的补集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = [...arr1,...arr2];</span><br><span class="line">newarr = <span class="keyword">new</span> <span class="built_in">Set</span>(newarr);</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> new1) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newarr.has(v))&#123;</span><br><span class="line">        newarr.delete(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,4,5]</span></span><br></pre></td></tr></table></figure>
<h1 id="二-Map"><a href="#二-Map" class="headerlink" title="二.Map"></a>二.Map</h1><p><strong>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;惠新浩&#x27;</span>);</span><br><span class="line">m.set(<span class="string">&#x27;change&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;change&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125095306585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>set()<br>使用set方法为Map对象添加键值对 其允许传入两个参数（键名，键值）。</li>
<li>get()<br>使用get方法读取键名所对应的键值。</li>
<li>其余方法类似于Set</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>ES6-模块化</title>
    <url>/2020/11/26/ES6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
</blockquote>
<h1 id="模块功能命令"><a href="#模块功能命令" class="headerlink" title="模块功能命令"></a>模块功能命令</h1><h3 id="一-export命令"><a href="#一-export命令" class="headerlink" title="一. export命令"></a>一.<font color="blue"> export</font>命令</h3><blockquote>
<p>export命令用于规定模块的对外接口。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
</blockquote>
<h6 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h6><ol>
<li>在变量/函数声明前添加<font color="red"> export</font></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在脚本末尾用大括号括起来，优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;</span><br><span class="line">    name,n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二-import命令"><a href="#二-import命令" class="headerlink" title="二. import命令"></a>二.<font color="blue"> import</font>命令</h3><blockquote>
<p>import命令用于输入其他模块提供的功能。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/11/30/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="函数对象-实例对象"><a href="#函数对象-实例对象" class="headerlink" title="函数对象,实例对象"></a>函数对象,实例对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;<span class="comment">//Fn函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn();<span class="comment">//此时Fn叫做构造函数 </span></span><br><span class="line">                <span class="comment">//f是Fn构造出来的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.bind());<span class="comment">//通过.来调用Funciton原型上的属性或方法</span></span><br><span class="line">                        <span class="comment">//叫做函数对象</span></span><br></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);<span class="comment">//不进入回调队列</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);<span class="comment">//这个函数进入回调队列排队</span></span><br><span class="line">    <span class="comment">//回调队列：JS在运行时候，有一个列表用于记录将要处理的回调事件。遵循FIFO（先进先出）原则。</span></span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;,,,&#x27;</span>);</span><br><span class="line"><span class="comment">//，，，</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><p>当所有promise对象都成功时返回一个promise数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213637729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all resolved"><br>只要有一个不成功则返回失败的reason</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213813769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all rejected"></p>
<h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><p>race返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130214412804.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol>
<li>error属于promise的rejected状态</li>
<li>当一个promise指定了多个成功/失败的函数时，promise改变成哪个状态就调用哪个状态的函数。</li>
<li>状态改变与指定回调函数的先后次序<br>1&gt;先指定回调函数，则需要将当前指定的回调函数保存起来， 后改变状态，同时指定数据。<br>2&gt;先改变状态，后指定回调函数，异步执行回调函数。</li>
<li> promise.then()方法返回新的promise的结果<br>1&gt;抛出错误 返回rejected reason就是抛出的错误<br>2&gt;返回非promise结果    返回resolved<br>3&gt;返回新的promise 外部promise的状态由内部promise的状态决定。</li>
<li>promsie如何串联多个操作任务？<br>promise的then方法返回一个promise对象，可以通过对then方法的链式调用串联多个任务。</li>
<li>promsie值穿透<br>如下代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);<span class="comment">//foo</span></span><br></pre></td></tr></table></figure>
如果给then传入的是非函数的值，相当于传入的是null</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin().then(functiuoin () &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>中断promise链<br>当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获。利用这个特性能跳过链中函数的调用，直至链路终点，变相地结束Promise链。然而，若链路中也对错误进行了捕获，则后续的函数可能会继续执行。此时可以返回一个无参数的promsie对象来中断promsie链。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_1]&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;); <span class="comment">// 返回“pending”状态的Promise对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;                   <span class="comment">// 后续的函数不会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_2]&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[catch]&#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// =&gt; [onFulfilled_1]</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
