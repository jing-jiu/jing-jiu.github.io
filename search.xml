<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-模块化</title>
    <url>/2020/11/26/ES6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
</blockquote>
<h1 id="模块功能命令"><a href="#模块功能命令" class="headerlink" title="模块功能命令"></a>模块功能命令</h1><h3 id="一-export命令"><a href="#一-export命令" class="headerlink" title="一. export命令"></a>一.<font color="blue"> export</font>命令</h3><blockquote>
<p>export命令用于规定模块的对外接口。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
</blockquote>
<h6 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h6><ol>
<li>在变量/函数声明前添加<font color="red"> export</font></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在脚本末尾用大括号括起来，优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;</span><br><span class="line">    name,n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二-import命令"><a href="#二-import命令" class="headerlink" title="二. import命令"></a>二.<font color="blue"> import</font>命令</h3><blockquote>
<p>import命令用于输入其他模块提供的功能。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>ES6-Class</title>
    <url>/2020/11/25/ES6-Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h4 id="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"><a href="#由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。" class="headerlink" title="由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。"></a>由于原先的（ES5）中生成实例对象的语法与传统面向对象语言的区别较大，ES6引入了Class（类）的语法糖，使生成实例对象更接近于传统语言。</h4><blockquote>
<p>ES5生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">p.sayname();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,p.age);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020112510551285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>ES6生成实例对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">//相当于构造函数内部</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//相当于prototype</span></span><br><span class="line">   <span class="function"><span class="title">sayname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hxh&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201125105223617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用static声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&#x27;hxh&#x27;</span>;</span><br><span class="line">	<span class="keyword">static</span> age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.name,Person.name,Person.age);</span><br><span class="line"><span class="comment">//undefined &quot;hxh&quot; 18</span></span><br><span class="line"><span class="comment">//不使用static声明</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">class Person&#123;</span></span><br><span class="line"><span class="string">name = &#x27;hxh&#x27;;</span></span><br><span class="line"><span class="string">    age = 18;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let p = new Person();</span></span><br><span class="line"><span class="string">console.log(p.name,Person.name,Person.age);</span></span><br><span class="line"><span class="string">//hxh Person undefined  </span></span><br><span class="line"><span class="string">//其中Person.name是显示其自身的函数名与内部的name属性无关</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>ES5构造函数继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">name,size</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">&#125;<span class="comment">//父级方法</span></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;<span class="comment">//父级原型上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sphone</span>(<span class="params">name,size,effect</span>) </span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>,name,size);</span><br><span class="line">    <span class="built_in">this</span>.effect = effect;</span><br><span class="line">&#125;<span class="comment">//子级继承父级的方法属性  </span></span><br><span class="line">Sphone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line">Sphone.prototype.constructor = Sphone;</span><br><span class="line">Sphone.prototype.app = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">&#125;<span class="comment">//子级私有方法</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">1200</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126090011498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>ES6类的继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name,size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;  <span class="comment">//使用extends关键字继承方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,size,effect</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,size);<span class="comment">//使用super关键字调用</span></span><br><span class="line">        <span class="built_in">this</span>.effect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">app</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sphone(<span class="string">&#x27;huawei&#x27;</span>,<span class="number">40</span>,<span class="string">&#x27;call&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201126100454582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>ES6-Promise</title>
    <url>/2020/11/23/ES6-Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promsie"><a href="#Promsie" class="headerlink" title="Promsie"></a>Promsie</h1><p><strong>是异步编程的一种解决方案（其他的解决方式还有回调函数，监听，发布/订阅等）</strong></p>
<h1 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h1><p>使用构造函数来创建一个promise对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Promsie这个构造函数会把一个处理器函数(excutor)作为自己的参数 这个函数接收resolve，reject两个函数作为参数。<br>说明：excutor会在Promise内部立即执行，异步操作会在执行器执行<br>当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因时，会调用reject 函数。<br>状态：pedding–&gt;resolved    pedding–&gt;rejected<br>注：error属于失败<br><img src="https://img-blog.csdnimg.cn/20201130214548640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="error"></p>
<p><img src="https://img-blog.csdnimg.cn/20201130210334769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="promise"><br>例如在下面情境下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Promise(function(resolve, reject)&#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;C:/Users/14828/Desktop/代码/ES6/ES6_Promise/resources/为学.md&quot;</span>, (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码是在node环境中  利用promise封装读取文件内容<br>如果出现错误则调用reject函数  并传入错误信息  反之调用resolve函数  并传入数据。</p>
<h1 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h1><p>可以使用promise.then()，promise.catch() promise.finally()方法来进行进一步的操作。（将进一步的操作与一个变为已确定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象）</p>
<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>大致原理</title>
    <url>/2021/02/15/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原理-简易版"><a href="#原理-简易版" class="headerlink" title="原理(简易版)"></a>原理(简易版)</h1><h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><p>在构建一个Vue例时，你可能会传入以下参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">&quot;HXH&quot;</span>,</span><br><span class="line">        age:<span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;ZSW&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因此首先我们先声明一个Vue的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">        <span class="built_in">this</span>.$options = options</span><br><span class="line">        <span class="built_in">this</span>.$watchEvent = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.proxyData()</span><br><span class="line">        <span class="built_in">this</span>.observe()</span><br><span class="line">        <span class="built_in">this</span>.compile(<span class="built_in">this</span>.$el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>已知vue是一个mvvm模式的框架，那么如何实现数据的更新呢？就要用到get，set方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">proxyData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.$options.data) &#123;</span><br><span class="line">            <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,key,&#123;</span><br><span class="line">                configurable:<span class="literal">true</span>,</span><br><span class="line">                enumerable:<span class="literal">true</span>,</span><br><span class="line">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> _this.$options.data[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    _this.$options.data[key] = val</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>Object.defineProperty来劫持对象属性的setter和getter操作，并写入一个监听器，当数据发生变化的时候发出通知<br>此时我们需要在vue实例中绑定一个监听对象，对象中存放数据监听的内容。当数据发生变化时进行更新<br><img src="https://img-blog.csdnimg.cn/20210208194509380.png" alt="$watchEvent"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">observe</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.$options.data) &#123;</span><br><span class="line">            <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="built_in">this</span>.$options.data[key]</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$options.data,key,&#123;</span><br><span class="line">                configurable:<span class="literal">true</span>,</span><br><span class="line">                enumerable:<span class="literal">true</span>,</span><br><span class="line">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    value = val</span><br><span class="line">                    <span class="keyword">if</span>(_this.$watchEvent[key])&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(_this.$watchEvent[key]);</span><br><span class="line">                        _this.$watchEvent[key].forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                            item.update()<span class="comment">//更新函数</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>监听的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span></span>&#123;</span><br><span class="line">    <span class="comment">//vm--vue实例 key--发生改变的数据 node--dom对象 attr--dom属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">vm,key,node,attr</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.vm = vm</span><br><span class="line">        <span class="built_in">this</span>.key = key</span><br><span class="line">        <span class="built_in">this</span>.node = node</span><br><span class="line">        <span class="built_in">this</span>.attr = attr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//将数据更新到view视图上</span></span><br><span class="line">        <span class="built_in">this</span>.node[<span class="built_in">this</span>.attr] = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(cNode)&#123;</span><br><span class="line">    &#x2F;&#x2F;循环出app下的各个节点</span><br><span class="line">    cNode.childNodes.forEach((node)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;根据节点类型进行编译</span><br><span class="line">        if(node.nodeType &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            &#x2F;&#x2F;元素节点</span><br><span class="line">            if(node.hasAttribute(&#39;attribute&#39;))&#123;</span><br><span class="line">                &#x2F;&#x2F;attribute--在view绑定的属性</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>通过getAttribute方法获取属性的值<br>创建Watch实例创建数据与属性的联系并渲染数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.hasAttribute(<span class="string">&#x27;v-html&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">let</span> vmKey = node.getAttribute(<span class="string">&#x27;v-html&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.hasOwnProperty(vmKey))&#123;</span><br><span class="line">        node.innerHTML = <span class="built_in">this</span>[vmKey]</span><br><span class="line">        <span class="keyword">let</span> watcher = <span class="keyword">new</span> Watch(<span class="built_in">this</span>,vmKey,node,<span class="string">&#x27;innerHTML&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.$watchEvent[vmKey])&#123;</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey].push(watcher)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey] = []</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey].push(watcher)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.hasAttribute(<span class="string">&#x27;v-model&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">let</span> vmKey = node.getAttribute(<span class="string">&#x27;v-model&#x27;</span>).trim()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.hasOwnProperty(vmKey))&#123;</span><br><span class="line">        node.value = <span class="built_in">this</span>[vmKey]</span><br><span class="line">        <span class="keyword">let</span> watcher = <span class="keyword">new</span> Watch(<span class="built_in">this</span>,vmKey,node,<span class="string">&quot;value&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.$watchEvent[vmKey])&#123;</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey].push(watcher)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey] = []</span><br><span class="line">            <span class="built_in">this</span>.$watchEvent[vmKey].push(watcher)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>[vmKey] = node.value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="click"><a href="#click" class="headerlink" title="@click"></a>@click</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.hasAttribute(<span class="string">&#x27;@click&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">let</span> vmKey = node.getAttribute(<span class="string">&#x27;@click&#x27;</span>).trim()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.$options.methods.hasOwnProperty(vmKey))&#123;</span><br><span class="line">        node.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="built_in">this</span>.$options.methods[vmKey].bind(<span class="built_in">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板语法-easy"><a href="#模板语法-easy" class="headerlink" title="模板语法(easy)"></a>模板语法(easy)</h3><p>你需要给挂载的元素内的所有dom节点都进行编译<br>才可获取到模板语法所在的文本节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.childNodes.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.compile(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用正则表达式找出模板语法并进行渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(node.nodeType &#x3D;&#x3D; 3)&#123;</span><br><span class="line">    &#x2F;&#x2F;文本类型</span><br><span class="line">    let reg &#x3D; &#x2F;\&#123;\&#123;(.*?)\&#125;\&#125;&#x2F;g;</span><br><span class="line">    let text &#x3D; node.textContent</span><br><span class="line">    node.textContent &#x3D; text.replace(reg,(match,vmKey)&#x3D;&gt;&#123;</span><br><span class="line">        vmKey &#x3D; vmKey.trim()</span><br><span class="line">        if(this.hasOwnProperty(vmKey))&#123;</span><br><span class="line">            node.textContent &#x3D; this[vmKey]</span><br><span class="line">            let watcher &#x3D; new Watch(this,vmKey,node,&quot;textContent&quot;)</span><br><span class="line">            if(this.$watchEvent[vmKey])&#123;</span><br><span class="line">                this.$watchEvent[vmKey].push(watcher)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                this.$watchEvent[vmKey] &#x3D; []</span><br><span class="line">                this.$watchEvent[vmKey].push(watcher)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return this[vmKey]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>深入原理</title>
    <url>/2021/02/15/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原理-进阶——vue2"><a href="#原理-进阶——vue2" class="headerlink" title="原理(进阶——vue2)"></a>原理(进阶——vue2)</h1><h2 id="一-defineReactive函数——响应式操作"><a href="#一-defineReactive函数——响应式操作" class="headerlink" title="一.defineReactive函数——响应式操作"></a>一.defineReactive函数——响应式操作</h2><h3 id="1-Object-defineProperty-函数"><a href="#1-Object-defineProperty-函数" class="headerlink" title="1.Object.defineProperty()函数"></a>1.Object.defineProperty()函数</h3><pre><code>要进行响应式操作就需要使用Object对象上的一个方法defineProperty()</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</span></span><br><span class="line"><span class="comment">//其接收三个参数</span></span><br><span class="line"><span class="comment">//obj</span></span><br><span class="line"><span class="comment">//要定义属性的对象。</span></span><br><span class="line"><span class="comment">//prop</span></span><br><span class="line"><span class="comment">//要定义或修改的属性的名称或 Symbol 。</span></span><br><span class="line"><span class="comment">//descriptor</span></span><br><span class="line"><span class="comment">//要定义或修改的属性描述符。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//value</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//注意:set,get函数不能与value,writable同时使用</span></span><br></pre></td></tr></table></figure>
<pre><code>而我们的defineReactive函数则是对defineProperty进行了简单的封装</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此处判断传入参数的个数   如果传入两个参数  进行value = obj[key]操作以便后面对一个对象身上含有多层属性进行递归</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>)&#123;</span><br><span class="line">        value = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;访问&#x27;</span>+key+<span class="string">&#x27;属性&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;修改&#x27;</span>+key+<span class="string">&#x27;属性&#x27;</span>);</span><br><span class="line">            value = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-Observer类——观察者"><a href="#二-Observer类——观察者" class="headerlink" title="二.Observer类——观察者"></a>二.Observer类——观察者</h2><h3 id="1-observe函数"><a href="#1-observe函数" class="headerlink" title="1.observe函数"></a>1.observe函数</h3><pre><code>我们需要一个函数来判断一个数据是否需要为其进行响应式操作</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的value是否为一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ob</span><br><span class="line">        <span class="comment">//判断对象身上是否有一个__ob__属性  这个属性里面存放该对象的Observer类用于观察对象身上的属性</span></span><br><span class="line">        <span class="keyword">if</span>(value.__ob__)&#123;</span><br><span class="line">            ob = value.__ob__</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>我们需要在defineReactive函数内部去调用它 1.给子对象添加观察 2.给新的值添加观察</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//给子对象添加观察</span></span><br><span class="line">    <span class="keyword">let</span> childOb = observe(value)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//给新的值添加观察</span></span><br><span class="line">            childOb = observe(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-def函数"><a href="#2-def函数" class="headerlink" title="2.def函数"></a>2.def函数</h3><pre><code>我们需要在Oberver中对传入的对象/数组添加一个属性,属性中存放一个Oberver实例用于观察这个对象的数据变化</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Observer类"><a href="#3-Observer类" class="headerlink" title="3.Observer类"></a>3.Observer类</h3><pre><code>在Observer类中我们需要对属性进行观察 并且我们需要在observe中实例化他</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        def(value,<span class="string">&#x27;__ob__&#x27;</span>,<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">            <span class="built_in">this</span>.arrWalk(value)</span><br><span class="line">            <span class="built_in">Object</span>.setPrototypeOf(value,arrMethods);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            defineReactive(obj,key)</span><br><span class="line">       &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">arrWalk</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-数组的观察——重写方法"><a href="#4-数组的观察——重写方法" class="headerlink" title="4.数组的观察——重写方法"></a>4.数组的观察——重写方法</h3><pre><code>由于数组与对象不同   defineReactive无法监测他的增删添改 因此我们需要对数组原型上的七种方法进行重写,方便我们监听它</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsNeedChange = [<span class="comment">//要重写的七种方法</span></span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//将Array原型绑定到arrMethods上 即arrMethods.prototype === Array.prototype</span></span><br><span class="line"><span class="keyword">let</span> arrMethods = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype)</span><br><span class="line">methodsNeedChange.forEach(</span><br><span class="line">    methods =&gt; &#123;</span><br><span class="line">        <span class="comment">//保存原来的七个方法</span></span><br><span class="line">        <span class="keyword">let</span> oldMethods = <span class="built_in">Array</span>.prototype[methods]</span><br><span class="line">        <span class="comment">//重写方法 用def监测</span></span><br><span class="line">        def(arrMethods,methods,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//当我们调用Array原型上的方法时,此时调用未重写的方法对数组进行正确的操作</span></span><br><span class="line">            <span class="keyword">let</span> result = oldMethods.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">let</span> newArr = []<span class="comment">//存放改变后的数组</span></span><br><span class="line">            <span class="keyword">let</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">            <span class="keyword">let</span> arr = [...arguments]<span class="comment">//防止是类数组无法调用slice方法</span></span><br><span class="line">            <span class="keyword">switch</span> (methods) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:   </span><br><span class="line">                    newArr = <span class="built_in">arguments</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;slice&#x27;</span>: </span><br><span class="line">                    newArr = arr.slice(<span class="number">2</span>)  </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(newArr)&#123;</span><br><span class="line">                <span class="comment">//在这里响应</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;使用了&#x27;</span>+ oldMethods.name +<span class="string">&#x27;方法&#x27;</span>);</span><br><span class="line">                <span class="comment">//如果数据变化  把新的数据更新</span></span><br><span class="line">                ob.arrWalk(newArr)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<pre><code>而此时arrMethods上就存放了可以被监听的七种方法  我们在需要这七种方法时,也就是observe时将传数组的原型改成arrMethods,这样我们的数组调用数组的方法也就能够被监听到   如下:</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">arrWalk</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,l = arr.length;i&lt;l;i++)&#123;</span><br><span class="line">      <span class="comment">//逐项进行observe</span></span><br><span class="line">      observe(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-Dep类——依赖收集"><a href="#三-Dep类——依赖收集" class="headerlink" title="三.Dep类——依赖收集"></a>三.Dep类——依赖收集</h2><pre><code>在vue中,可能我们在vue实例内部定义的数据不一定会同时使用数据,我们没必要给未使用的数据进行响应式处理.因此我们需要判断那些数据是正在被使用的,然后打上标记,这个标记要求是在全局唯一的位置进行存放.一般来说我们选择Dep类,标记为Dep.target当然你也可以选择window对象来存放.</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs = [] <span class="comment">//定义一个数组用来存放依赖——Watcher类的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sub = <span class="built_in">this</span>.subs.slice() <span class="comment">//浅拷贝一份依赖数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sub.length; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历数组 通知所有观察者数据更新</span></span><br><span class="line">            sub[i].update()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">            <span class="built_in">this</span>.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>我们需要在defineReactive函数,Observer类中实例化Dep类</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//在getter收集依赖</span></span><br><span class="line">            <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">                dep.depend()</span><br><span class="line">                <span class="keyword">if</span>(childOb)&#123;</span><br><span class="line">                    childOb.dep.depend()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//在setter发布更新</span></span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-Watcher类——订阅者"><a href="#四-Watcher类——订阅者" class="headerlink" title="四.Watcher类——订阅者"></a>四.Watcher类——订阅者</h2><pre><code>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。</code></pre>
<h3 id="1-Watcher类"><a href="#1-Watcher类" class="headerlink" title="1.Watcher类"></a>1.Watcher类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">target,expression,callback</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target</span><br><span class="line">        <span class="built_in">this</span>.getter = parsePath(expression)</span><br><span class="line">        <span class="built_in">this</span>.callback = callback</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()<span class="comment">//获取访问的属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//将这个Watcher实例存放到Dep.target上</span></span><br><span class="line">        Dep.target = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> obj = <span class="built_in">this</span>.target</span><br><span class="line">        <span class="keyword">var</span> value</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过getter方法获取到最新的value值</span></span><br><span class="line">            value = <span class="built_in">this</span>.getter(obj)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了~~~&#x27;</span>) </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            Dep.target = <span class="literal">null</span> <span class="comment">//让这个实例从Dep.target上推下，让其他的实例上位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getAndInvoke(<span class="built_in">this</span>.callback)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getAndInvoke</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">        <span class="keyword">if</span>(value !== <span class="built_in">this</span>.value || <span class="keyword">typeof</span> value == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> oldVlaue = <span class="built_in">this</span>.value</span><br><span class="line">            cb.call(<span class="built_in">this</span>.target,value,oldVlaue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-parsePath函数——根据提供的路径寻找对象身上的属性"><a href="#2-parsePath函数——根据提供的路径寻找对象身上的属性" class="headerlink" title="2.parsePath函数——根据提供的路径寻找对象身上的属性"></a>2.parsePath函数——根据提供的路径寻找对象身上的属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            obj = obj[arr[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Vue概念</title>
    <url>/2021/02/02/%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-软件架构模式"><a href="#一-软件架构模式" class="headerlink" title="一.软件架构模式"></a>一.软件架构模式</h1><h2 id="MVC模式简介"><a href="#MVC模式简介" class="headerlink" title="MVC模式简介"></a>MVC模式简介</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="img"></p>
<p>M–&gt;model–&gt;负责储存数据–&gt;对象，数组等变量</p>
<p>V–&gt;view–&gt;用户所看到的界面(html,css)</p>
<p>C–&gt;controller–&gt;业务逻辑（事件交互  如何根据视图与用户的交互改变数据–&gt;操作DOM对象进行事件的绑定）</p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<p>eg: Backbone.JS</p>
<ol>
<li><p>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p>
</li>
<li><p>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p>
</li>
<li><p>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p>
</li>
</ol>
<h2 id="MVP模式简介"><a href="#MVP模式简介" class="headerlink" title="MVP模式简介"></a>MVP模式简介</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt="img"></p>
<p>M–&gt;model–&gt;负责储存数据–&gt;对象，数据等变量</p>
<p>V–&gt;view–&gt;用户所看到的界面(html,css)</p>
<p>P–&gt;presenter–&gt; 包含着组件的事件处理，负责检索 Model 获取资料，和将获取的资料经过格式转换与 View 进行沟通。 </p>
<ol>
<li><p>各部分之间的通信，都是双向的。</p>
</li>
<li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p>
</li>
<li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p>
</li>
</ol>
<h2 id="MVVM模式简介"><a href="#MVVM模式简介" class="headerlink" title="MVVM模式简介"></a>MVVM模式简介</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p> 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Vue和Angular都采用这种模式。 </p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="img"></p>
<h1 id="二-VUE使用"><a href="#二-VUE使用" class="headerlink" title="二.VUE使用"></a>二.VUE使用</h1><h2 id="1-条件渲染"><a href="#1-条件渲染" class="headerlink" title="1.条件渲染"></a>1.条件渲染</h2><pre><code>1.v-if  --&gt;如果值为false则目标不会被渲染到页面上 若已经渲染到DOM上，则会从DOM中去除

2.v-show --&gt;display：none  会渲染到DOM上</code></pre>
<h2 id="2-列表渲染"><a href="#2-列表渲染" class="headerlink" title="2.列表渲染"></a>2.列表渲染</h2><pre><code>v-for 添加key属性可以使被渲染出的元素具有唯一性</code></pre>
<h2 id="3-模板语法"><a href="#3-模板语法" class="headerlink" title="3.模板语法"></a>3.模板语法</h2><pre><code>形如 &#123;&#123; H?a:b &#125;&#125; 可在其中添加简单的三元运算符</code></pre>
<h2 id="4-计算属性"><a href="#4-计算属性" class="headerlink" title="4.计算属性"></a>4.计算属性</h2><pre><code>在computed对象内定义计算规则并在view中调用 会将计算的结果保存  只要参数内容不修改,会调用保存的结果而不会重新计算</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Original message: <span class="string">&quot;&#123;&#123; message &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: <span class="string">&quot;&#123;&#123; reversedMessage &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-侦听属性"><a href="#5-侦听属性" class="headerlink" title="5.侦听属性"></a>5.侦听属性</h2><pre><code>在watch对象中定义需要监听数据的函数 数据改变就会执行该函数
watch对象中  对象的键名是要监听的数据变量名 键值是要执行的函数</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">	arr:<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(val)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-表单输入绑定"><a href="#6-表单输入绑定" class="headerlink" title="6.表单输入绑定"></a>6.表单输入绑定</h2><pre><code>使用v-model进行对数据进行双向数据绑定 修饰符……</code></pre>
<h2 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h2><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<h3 id="什么是vue生命周期？"><a href="#什么是vue生命周期？" class="headerlink" title="什么是vue生命周期？"></a>什么是vue生命周期？</h3><ul>
<li>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。在整个Vue实例的生命周期中会执行这些钩子函数<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3></li>
<li>实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据<h3 id="beforeCreate与created之间"><a href="#beforeCreate与created之间" class="headerlink" title="beforeCreate与created之间"></a>beforeCreate与created之间</h3></li>
<li>在beforeCreate与created之间进行初始化事件,数据的观测 绑定data数据，methods方法等<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3></li>
<li>实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到$el属性。$ref属性内容为空数组 <h3 id="created与beforeMount之间"><a href="#created与beforeMount之间" class="headerlink" title="created与beforeMount之间"></a>created与beforeMount之间</h3></li>
<li>首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)—–如果我们在后面继续调用vm.$mount(el),(挂载dom节点)可以发现代码继续向下执行了<br>接下–&gt;template参数选项的有无对生命周期的影响。<br>（1）.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（2）.如果没有template选项，则将外部HTML作为模板编译。<br>（3）.可以看到template中的模板优先级要高于outer HTML的优先级<br>修改代码如下, 在HTML结构中增加了一串html，在vue对象中增加了template选项： 可以发现template中的内容会覆盖outer HTML中的内容<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!--html中修改的--&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;message + <span class="string">&#x27;这是在outer HTML中的&#x27;</span>&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">&quot;&lt;h1&gt;&#123;&#123;message +&#x27;这是在template中的&#x27;&#125;&#125;&lt;/h1&gt;&quot;</span>, <span class="comment">//在vue配置项中修改的</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;Vue的生命周期&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
这下就可以想想什么el的判断要在template之前了~是因为vue需要通过el找到对应的outer template。<br>在vue对象中还有一个render函数(渲染函数)，它是以createElement作为参数，然后做渲染操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;this is 	createElement&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到页面中渲染的为this is createElement<br>因此优先级为render函数选项 &gt; template选项 &gt; outer HTML</p>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p>在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数  给Vue实例添加$el成员   此时的this.$el就是一个    DOM对象  但可以发现，此时 h1中还是通进行占位 因为此时还未挂载到页面上   此时仍是虚拟DOM的形式存在 </p>
<p><img src="https://img-blog.csdnimg.cn/20210208194651878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70"></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问  h1处不再是用占位。</p>
<p><img src="https://img-blog.csdnimg.cn/20210208194617581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70"></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li>响应式数据更新时调用，发生在虚拟DOM打补丁之前 </li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li>虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li>实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p>实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 </p>
<h2 id="8-组件基础"><a href="#8-组件基础" class="headerlink" title="8.组件基础"></a>8.组件基础</h2><h3 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h3><p>调用Vue对象的component方法传入自定义组件名称，以及模板等,与根组件唯一区别是无el挂载点。之后就可以在html中通过<hello></hello>形式调用组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">    <span class="string">&#x27;hello&#x27;</span>:Vue.component(<span class="string">&#x27;hello&#x27;</span>,&#123;</span><br><span class="line">        template:<span class="string">&#x27;&lt;h1 @click=&quot;change&quot;&gt;&#123;&#123;hxh&#125;&#125;&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                hxh:<span class="string">&#x27;hello 浩哥&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.hxh = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="组件间通信-props"><a href="#组件间通信-props" class="headerlink" title="组件间通信(props)"></a>组件间通信(props)</h3><h4 id="1-父子组件"><a href="#1-父子组件" class="headerlink" title="1.父子组件"></a>1.父子组件</h4><pre><code>1&gt;父传子
在子组件中添加props数组  存放与父组件通信的属性名称 父组件可以把内容通过在props中添加的属性传入子组件中</code></pre>
<p>  <strong>如果传给子组件的是一个方法，子组件也可以调用该方法。其中父组件方法的this指向父组件，而不是调用的组件。因此子组件调用该方法也可以操作父组件</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:title</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">也可以=&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">hello</span> <span class="attr">title</span>=<span class="string">&#x27;ruarua&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    name:ruarua</span><br><span class="line">&#125;</span><br><span class="line">components:&#123;</span><br><span class="line"> <span class="string">&#x27;hello&#x27;</span>:Vue.component(<span class="string">&#x27;hello&#x27;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">    template:<span class="string">&#x27;&lt;h1 @click=&quot;change&quot;&gt;&#123;&#123;hxh+title&#125;&#125;&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">          hxh:<span class="string">&#x27;hello 浩哥&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还可以使用更简单的方法来操作</strong>  如果在子组件打印this就会发现，this身上绑定了一个$parent属性，你会发现this.$parent === app.因此可以这样**@click=’$parent.show(item)’**<br><strong>但是为了降低耦合不建议这样操作</strong><br>    2&gt;子传父</p>
<p>  使用$emit方法将子组件的值抛出(<strong>this.$emit(‘foodshow’,data)</strong>),这个方法接收两个参数–&gt;(‘自定义参数’,‘要抛出的变量’)   在父组件使用组件的位置用自定义事件接收  作为函数的一个参数传入方法中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">food</span> <span class="attr">name</span>=<span class="string">&#x27;water&#x27;</span> @<span class="attr">foodshow</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;food&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line"> <span class="string">&#x27;food&#x27;</span>:Vue.component(<span class="string">&#x27;food&#x27;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    template:<span class="string">`&lt;div&gt;&lt;h1 v-for=&#x27;item in foods&#x27; @click=&#x27;show(item)&#x27;&gt;&#123;&#123;name&#125;&#125;:&#123;&#123;item&#125;&#125;&lt;/h1&gt;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         foods:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      show:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;foodshow&#x27;</span>,data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，在父组件中有一个$children <strong>但是为了降低耦合不建议这样操作</strong></p>
<h4 id="2-兄弟组件"><a href="#2-兄弟组件" class="headerlink" title="2.兄弟组件"></a>2.兄弟组件</h4><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>以input上的v-model为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;user($event)&#x27;</span>&gt;</span><br><span class="line"><span class="function"><span class="title">getValue</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.value = event.target.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件上"><a href="#组件上" class="headerlink" title="组件上"></a>组件上</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">等价于</span><br><span class="line">&lt;custom-input</span><br><span class="line">  v-model=&#x27;searchText&#x27;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props:[<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;,                             $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="插槽——slot"><a href="#插槽——slot" class="headerlink" title="插槽——slot"></a>插槽——slot</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>如果你想在组件内添加一些元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">//只需要在template中添加插槽<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">//但注意:插槽不能添加在根元素外部</span><br></pre></td></tr></table></figure>
<h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>如果并未在组件添加元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">//slot中的内容将会被渲染到页面</span><br></pre></td></tr></table></figure>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>如果你想添加多个插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>HXH<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:age</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">p</span>&gt;</span>18<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">//将你需要添加的元素用template标签包裹 并用v-slot:age的形式声明你想要传给的插槽</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过&lt;slot name=&#x27;age&#x27;&gt;&lt;/slot&gt;接收出入的元素</span></span><br><span class="line"><span class="comment">//没有name属性的template默认name=&#x27;default&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>如果你希望在使用组件时能够操作组件内部的数据 **v-slot: === # **</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span><br><span class="line">    //v-slot:default=&quot;data&quot; data是你自定义的props插槽名称 你可以在template元素内部调用子组件的某些数据</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&#x27;show(data)&#x27;</span>&gt;</span>&#123;&#123;data&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span>//text是你能在父组件操作的数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>如果你想动态的把自定义组件渲染到页面上<br>在组件上添加is属性 **:is=’com’ **com就是要渲染的组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show(1)&#x27;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show(2)&#x27;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show(3)&#x27;</span>&gt;</span>javascript<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show(4)&#x27;</span>&gt;</span>nodejs<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在控制台打印vue实例可以看到 所有声明的组件都放在实例的$options对象的components属性上可以通过调用**this.$options.components[com1]**获取到要渲染的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> com1 = Vue.component(<span class="string">&#x27;java&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">` &lt;h1&gt;JAVA&lt;/h1&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> com2 = Vue.component(<span class="string">&#x27;python&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">` &lt;h1&gt;PYTHON&lt;/h1&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> com3 = Vue.component(<span class="string">&#x27;javascript&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">` &lt;h1&gt;JAVASCRIPT&lt;/h1&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> com4 = Vue.component(<span class="string">&#x27;nodejs&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">` &lt;h1&gt;NODE-JS&lt;/h1&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        com:com1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="function"><span class="title">show</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.com = 		               		<span class="built_in">this</span>.$options.components[<span class="string">&#x27;com&#x27;</span>+id]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        com1,com2,com3,com4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="9-Vue-cli"><a href="#9-Vue-cli" class="headerlink" title="9.Vue-cli"></a>9.Vue-cli</h2>]]></content>
  </entry>
  <entry>
    <title>JQuery与DOM对象</title>
    <url>/2020/12/14/JQuery%E5%AF%B9%E8%B1%A1%E4%B8%8EDOM%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-什么是DOM对象"><a href="#一-什么是DOM对象" class="headerlink" title="一.什么是DOM对象"></a>一.什么是DOM对象</h2><blockquote>
<h4>文档对象模型简称DOM，是W3C组织推荐的处理可扩展置标语言的标准编程接口。</h4>
</blockquote>
<ul>
<li>DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。</li>
<li>通过DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的
</li><li>内容进行修改和删除，同时也可以创建新的元素。</li>
<li>DOM 独立于平台和编程语言。它可被任何编程语言诸如 Java、JavaScript 和
VBScript 使用。</li>
<li>DOM对象，即是我们用传统的方法(javascript)获得的对象。</li>
<li>DOM准确说是对文档对象的一种规范标准(文档对象模型),标准只定义了属性和方法行为。</li>

<h2 id="二-什么是JQuery对象"><a href="#二-什么是JQuery对象" class="headerlink" title="二.什么是JQuery对象"></a>二.什么是JQuery对象</h2><blockquote>
<h4>就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的，其可以使用jQuery里的方法。但是不能使用DOM的方法;反过来DOM对象也不能使用</h4>
</blockquote>
<ul>
<li>jQuery对象属于类数组对象，可以通过它的toArray方法转换成数组.</li>
<li>虽然jquery对象是包装DOM对象产生的对象，但是他不能使用DOM对象的方法。如
$("#test").innerHTML、document.getElementById("id").html().</li>

<h2 id="三-相互转换"><a href="#三-相互转换" class="headerlink" title="三.相互转换"></a>三.相互转换</h2><pre><code>1.jquery转dom
        因为他是一个类数组对象，可以使用jquery[index]获取数组中保存的dom对象
        也可以使用jquery中的get方法。当get方法不传参时，会将jquery转换成数组。
2.dom转jquery
        将dom对象放入jquery的入口函数内部，就会将该dom元素转换为一个jquery对象    $()。</code></pre>
</ul></ul>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>ES6-Set与Map集合</title>
    <url>/2020/11/25/ES6-Set%E4%B8%8EMap%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-Set"><a href="#一-Set" class="headerlink" title="一.Set"></a>一.Set</h1><h2 id="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"><a href="#ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。" class="headerlink" title="ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。"></a>ES6新增的Set类型是一种有序列表，其中含有一些相互独立的非重复值。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125084002138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以看到Set会返回给你一组不重复的值，且在Set的原型上保存了一些方法和属性。</p>
<blockquote>
<ol>
<li>size属性<br>size内保存的是Set对象内部的长度</li>
<li>add()方法<br>使用add()方法可以为Set添加成员  但如果添加的成员在Set内已经存在，则不会添加。</li>
<li>has()方法<br>使用has()方法传入参数来检测Set内部是否含有该成员  </li>
<li>delete()方法<br>使用delete()方法删除目标成员，Set内部如果有则删除并返回true，反之返回false</li>
<li>clear()方法<br>使用clear()方法清空Set内部的所有成员</li>
<li>entries()方法<br>返回一个迭代器对象iterator   因此也可以使用for…of来遍历Set对象<br><img src="https://img-blog.csdnimg.cn/20201125091343969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center"></li>
</ol>
</blockquote>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><blockquote>
<ol>
<li>使用Set与扩展运算符…来进行数组去重。</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr = [...new <span class="built_in">Set</span>(arr)]);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>使用Set实现交集，并集，补集</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1,...arr2]);</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(new1);<span class="comment">//[3]</span></span><br><span class="line"><span class="comment">//交集的补集</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newarr = [...arr1,...arr2];</span><br><span class="line">newarr = <span class="keyword">new</span> <span class="built_in">Set</span>(newarr);</span><br><span class="line"><span class="keyword">var</span> new1 = arr1.filter(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(v))&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> new1) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newarr.has(v))&#123;</span><br><span class="line">        newarr.delete(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newarr);<span class="comment">//[1,2,4,5]</span></span><br></pre></td></tr></table></figure>
<h1 id="二-Map"><a href="#二-Map" class="headerlink" title="二.Map"></a>二.Map</h1><p><strong>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;惠新浩&#x27;</span>);</span><br><span class="line">m.set(<span class="string">&#x27;change&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;change&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201125095306585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>set()<br>使用set方法为Map对象添加键值对 其允许传入两个参数（键名，键值）。</li>
<li>get()<br>使用get方法读取键名所对应的键值。</li>
<li>其余方法类似于Set</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/11/30/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="函数对象-实例对象"><a href="#函数对象-实例对象" class="headerlink" title="函数对象,实例对象"></a>函数对象,实例对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;<span class="comment">//Fn函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn();<span class="comment">//此时Fn叫做构造函数 </span></span><br><span class="line">                <span class="comment">//f是Fn构造出来的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.bind());<span class="comment">//通过.来调用Funciton原型上的属性或方法</span></span><br><span class="line">                        <span class="comment">//叫做函数对象</span></span><br></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);<span class="comment">//不进入回调队列</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;...&#x27;</span>);<span class="comment">//这个函数进入回调队列排队</span></span><br><span class="line">    <span class="comment">//回调队列：JS在运行时候，有一个列表用于记录将要处理的回调事件。遵循FIFO（先进先出）原则。</span></span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;,,,&#x27;</span>);</span><br><span class="line"><span class="comment">//，，，</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><p>当所有promise对象都成功时返回一个promise数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213637729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all resolved"><br>只要有一个不成功则返回失败的reason</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.all([p1,p2,p3]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130213813769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="all rejected"></p>
<h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><p>race返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130214412804.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.race([p1, p2]));</span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol>
<li>error属于promise的rejected状态</li>
<li>当一个promise指定了多个成功/失败的函数时，promise改变成哪个状态就调用哪个状态的函数。</li>
<li>状态改变与指定回调函数的先后次序<br>1&gt;先指定回调函数，则需要将当前指定的回调函数保存起来， 后改变状态，同时指定数据。<br>2&gt;先改变状态，后指定回调函数，异步执行回调函数。</li>
<li> promise.then()方法返回新的promise的结果<br>1&gt;抛出错误 返回rejected reason就是抛出的错误<br>2&gt;返回非promise结果    返回resolved<br>3&gt;返回新的promise 外部promise的状态由内部promise的状态决定。</li>
<li>promsie如何串联多个操作任务？<br>promise的then方法返回一个promise对象，可以通过对then方法的链式调用串联多个任务。</li>
<li>promsie值穿透<br>如下代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);<span class="comment">//foo</span></span><br></pre></td></tr></table></figure>
如果给then传入的是非函数的值，相当于传入的是null</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomethin().then(functiuoin () &#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>中断promise链<br>当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获。利用这个特性能跳过链中函数的调用，直至链路终点，变相地结束Promise链。然而，若链路中也对错误进行了捕获，则后续的函数可能会继续执行。此时可以返回一个无参数的promsie对象来中断promsie链。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_1]&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;); <span class="comment">// 返回“pending”状态的Promise对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;                   <span class="comment">// 后续的函数不会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[onFulfilled_2]&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;[catch]&#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// =&gt; [onFulfilled_1]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201204212254565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjcxMTkz,size_16,color_FFFFFF,t_70" alt="思维导图"></p>
<h3 id="函数版本代码"><a href="#函数版本代码" class="headerlink" title="函数版本代码"></a>函数版本代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        _this.promiseState = PENDING;<span class="comment">//promise状态</span></span><br><span class="line">        _this.promiseResult = <span class="literal">undefined</span>;<span class="comment">//promise返回的结果</span></span><br><span class="line">        _this.callbacks = [];<span class="comment">//每个元素的结构==&gt;对象&#123;onresolve()&#123;&#125;,onrejecte()&#123;&#125;&#125;</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//1.将状态改为fulfilled</span></span><br><span class="line">                _this.promiseState = RESOLVED;</span><br><span class="line">                <span class="comment">//2.保存value值</span></span><br><span class="line">                _this.promiseResult = value;</span><br><span class="line">                <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    _this.callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                        obj.onresolve(value);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">                <span class="comment">//1.将状态改为rejected</span></span><br><span class="line">                _this.promiseState = REJECTED;</span><br><span class="line">                <span class="comment">//2.保存reason值</span></span><br><span class="line">                _this.promiseResult = reason;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&quot;Uncaught (in promise)&quot;</span>+reason);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                        obj.onrejected(reason);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行器函数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excutor(resolve,reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的resolve函数  返回一个指定结果为成功的对象</span></span><br><span class="line">    <span class="comment">//其成功的值就是其传入的value值</span></span><br><span class="line">    promise.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                value.then(re,rj)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                re(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的reject函数  返回一个指定结果为失败的对象</span></span><br><span class="line">    <span class="comment">//其失败的值就是其传入的reason值  并抛出错误</span></span><br><span class="line">    promise.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            rj(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的all方法</span></span><br><span class="line">    <span class="comment">//当所有promise对象都成功返回一个数组 数组内是成功的值  当其中某个失败  返回失败的结果</span></span><br><span class="line">    promise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);<span class="comment">//创建一个数组保存成功的value</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">p,index</span>) =&gt;</span> &#123;</span><br><span class="line">                promise.resolve(p).then(</span><br><span class="line">                    value=&gt;&#123;</span><br><span class="line">                        values[index] = value</span><br><span class="line">                        flag++</span><br><span class="line">                        <span class="keyword">if</span>(flag===promises.length)&#123;</span><br><span class="line">                            re(values);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                        rj(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数对象的race方法</span></span><br><span class="line">    <span class="comment">//哪个promise对象先改变状态就返回哪个的值value/reason</span></span><br><span class="line">    promise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">            promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                promise.resolve(p).then(</span><br><span class="line">                    value=&gt;&#123;</span><br><span class="line">                        re(value)</span><br><span class="line">                    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                        rj(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数原型对象上的then方法</span></span><br><span class="line">    <span class="comment">//传入两个函数处理成功,失败的结果</span></span><br><span class="line">    promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onresolve,onrejected</span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//指定默认成功的回调   穿透</span></span><br><span class="line">        onresolve = <span class="keyword">typeof</span> onresolve===<span class="string">&#x27;function&#x27;</span> ? onresolve : <span class="function"><span class="params">value</span>=&gt;</span>value;</span><br><span class="line">        <span class="comment">//指定默认失败的回调函数</span></span><br><span class="line">        onrejected = <span class="keyword">typeof</span> onrejected===<span class="string">&#x27;function&#x27;</span> ? onrejected : <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="built_in">console</span>.error(reason); <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">            <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">            <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装处理函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//result 是把成功的值传给then成功的函数 </span></span><br><span class="line">                    <span class="keyword">const</span> result = callback(_this.promiseResult);</span><br><span class="line">                    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                        <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                        result.then(</span><br><span class="line">                            <span class="comment">//value =&gt; resolve(value),当result成功时 then的promise也成功</span></span><br><span class="line">                            <span class="comment">//reason=&gt; reject(reason)当result失败时 then的promise也失败</span></span><br><span class="line">                            resolve,reject</span><br><span class="line">                        )</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(_this.promiseState === PENDING)&#123;</span><br><span class="line">                <span class="comment">//如果为pending 将传入的参数保存到callbacks中</span></span><br><span class="line">                _this.callbacks.push(&#123;</span><br><span class="line">                    <span class="function"><span class="title">onresolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                        handle(onresolve)</span><br><span class="line">                    &#125;,<span class="function"><span class="title">onrejected</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">                        handle(onrejected)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);  </span><br><span class="line">                <span class="comment">//如果为resolved 将then方法成功的函数保存</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === RESOLVED)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    handle(onresolve)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//如果为rejected 将传入的参数保存到callbacks中</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === REJECTED)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    handle(onrejected)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数原型对象上的catch方法 处理失败的结果</span></span><br><span class="line">    promise.prototype.Catch = <span class="function"><span class="keyword">function</span> (<span class="params">onrejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onrejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.promise = promise;<span class="comment">//向外暴露promise接口</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="class版本代码"><a href="#class版本代码" class="headerlink" title="class版本代码"></a>class版本代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">promise</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">            _this.promiseState = PENDING;<span class="comment">//promise状态</span></span><br><span class="line">            _this.promiseResult = <span class="literal">undefined</span>;<span class="comment">//promise返回的结果</span></span><br><span class="line">            _this.callbacks = [];<span class="comment">//每个元素的结构==&gt;对象&#123;onresolve()&#123;&#125;,onrejecte()&#123;&#125;&#125;</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//1.将状态改为fulfilled</span></span><br><span class="line">                    _this.promiseState = RESOLVED;</span><br><span class="line">                    <span class="comment">//2.保存value值</span></span><br><span class="line">                    _this.promiseResult = value;</span><br><span class="line">                    <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                    <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        _this.callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                            obj.onresolve(value);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState!==PENDING)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">                    <span class="comment">//1.将状态改为rejected</span></span><br><span class="line">                    _this.promiseState = REJECTED;</span><br><span class="line">                    <span class="comment">//2.保存reason值</span></span><br><span class="line">                    _this.promiseResult = reason;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&quot;Uncaught (in promise)&quot;</span>+reason);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//3.如果有回调函数 则进行异步调用</span></span><br><span class="line">                    <span class="keyword">if</span>(_this.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        callbacks.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">                            obj.onrejected(reason);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行器函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                excutor(resolve,reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//函数对象的resolve函数  返回一个指定结果为成功的对象</span></span><br><span class="line">        <span class="comment">//其成功的值就是其传入的value值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(value <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                    value.then(re,rj)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    re(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的reject函数  返回一个指定结果为失败的对象</span></span><br><span class="line">        <span class="comment">//其失败的值就是其传入的reason值  并抛出错误</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                rj(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的all方法</span></span><br><span class="line">        <span class="comment">//当所有promise对象都成功返回一个数组 数组内是成功的值  当其中某个失败  返回失败的结果</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);<span class="comment">//创建一个数组保存成功的value</span></span><br><span class="line">            <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                promises.forEach(<span class="function">(<span class="params">p,index</span>) =&gt;</span> &#123;</span><br><span class="line">                    promise.resolve(p).then(</span><br><span class="line">                        value=&gt;&#123;</span><br><span class="line">                            values[index] = value</span><br><span class="line">                            flag++</span><br><span class="line">                            <span class="keyword">if</span>(flag===promises.length)&#123;</span><br><span class="line">                                re(values);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            rj(reason)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数对象的race方法</span></span><br><span class="line">        <span class="comment">//哪个promise对象先改变状态就返回哪个的值value/reason</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">re,rj</span>)=&gt;</span>&#123;</span><br><span class="line">                promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">                    promise.resolve(p).then(</span><br><span class="line">                        value=&gt;&#123;</span><br><span class="line">                            re(value)</span><br><span class="line">                        &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">                            rj(reason)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//函数原型对象上的then方法</span></span><br><span class="line">        <span class="comment">//传入两个函数处理成功,失败的结果</span></span><br><span class="line">        <span class="function"><span class="title">then</span>(<span class="params">onresolve,onrejected</span>)</span> &#123;  </span><br><span class="line">            <span class="comment">//指定默认成功的回调   穿透</span></span><br><span class="line">            onresolve = <span class="keyword">typeof</span> onresolve===<span class="string">&#x27;function&#x27;</span> ? onresolve : <span class="function"><span class="params">value</span>=&gt;</span>value;</span><br><span class="line">            <span class="comment">//指定默认失败的回调函数</span></span><br><span class="line">            onrejected = <span class="keyword">typeof</span> onrejected===<span class="string">&#x27;function&#x27;</span> ? onrejected : <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="built_in">console</span>.error(reason); <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">            <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//封装处理函数</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//result 是把成功的值传给then成功的函数 </span></span><br><span class="line">                        <span class="keyword">const</span> result = callback(_this.promiseResult);</span><br><span class="line">                        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> promise)&#123;</span><br><span class="line">                            <span class="comment">//2.如果内部返回的是promise对象 then promise由该promise决定</span></span><br><span class="line">                            result.then(</span><br><span class="line">                                <span class="comment">//value =&gt; resolve(value),当result成功时 then的promise也成功</span></span><br><span class="line">                                <span class="comment">//reason=&gt; reject(reason)当result失败时 then的promise也失败</span></span><br><span class="line">                                resolve,reject</span><br><span class="line">                            )</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//1.如果内部返回的不是promise  then promise的状态为成功 返回value</span></span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        <span class="comment">//3.如果抛出错误   then promise返回rejected</span></span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(_this.promiseState === PENDING)&#123;</span><br><span class="line">                    <span class="comment">//如果为pending 将传入的参数保存到callbacks中</span></span><br><span class="line">                    _this.callbacks.push(&#123;</span><br><span class="line">                        <span class="function"><span class="title">onresolve</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            handle(onresolve)</span><br><span class="line">                        &#125;,<span class="function"><span class="title">onrejected</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            handle(onrejected)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);  </span><br><span class="line">                    <span class="comment">//如果为resolved 将then方法成功的函数保存</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === RESOLVED)&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        handle(onresolve)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//如果为rejected 将传入的参数保存到callbacks中</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_this.promiseState === REJECTED)&#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                        handle(onrejected)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数原型对象上的catch方法 处理失败的结果</span></span><br><span class="line">        <span class="function"><span class="title">Catch</span>(<span class="params">onrejected</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onrejected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.promise = promise;<span class="comment">//向外暴露promise接口</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
