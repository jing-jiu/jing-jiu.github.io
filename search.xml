<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>promise</title>
    <url>/2020/11/23/promise/</url>
    <content><![CDATA[<h1 id="Promsie"><a href="#Promsie" class="headerlink" title="Promsie"></a>Promsie</h1><p><strong>是异步编程的一种解决方案（其他的解决方式还有回调函数，监听，发布/订阅等）</strong></p>
<h1 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h1><p>使用构造函数来创建一个promise对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Promsie这个构造函数会把一个函数作为自己的参数 这个函数接收resolve，reject两个函数作为参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因时，会调用reject 函数。<br>例如在下面情境下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Promise(function(resolve, reject)&#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;C:/Users/14828/Desktop/代码/ES6/ES6_Promise/resources/为学.md&quot;</span>, (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码是在node环境中  利用promise封装读取文件内容<br>如果出现错误则调用reject函数  并传入错误信息  反之调用resolve函数  并传入数据。</p>
<h1 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h1><p>可以使用promise.then()，promise.catch() promise.finally()方法来进行进一步的操作。（将进一步的操作与一个变为已确定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象）</p>
<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        reject(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);<span class="comment">//Promise</span></span><br></pre></td></tr></table></figure>
<p>value就是调用resolve传入的参数，reason是调用reject传入的参数<br>而且promiss对象的状态由then的返回值决定<br>1.then返回结果是非promise对象  <br> promise状态为成功(fulfilled)  返回值是对象成功/失败的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(value);</span><br><span class="line">        return &#x27;value&#x27;;</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(reason);</span><br><span class="line">        return &#x27;reason&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122224548417.png#pic_center" alt="在这里插入图片描述"><br>2.then返回结果是promise对象<br>内部promise的返回状态决定了外部promise的返回状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    let result = p.then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          let data = &#x27;数据&#x27;;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,reason=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(result);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122225135675.png#pic_center" alt="在这里插入图片描述"><br>如果是reject<br><img src="https://img-blog.csdnimg.cn/20201122225221189.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>catch() 方法返回一个Promise，并且处理拒绝的情况，它的行为与调用then方法的reason相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    let data = &#x27;123&#x27;;</span><br><span class="line">    reject(data);</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      let data = &#x27;数据&#x27;;</span><br><span class="line">      reject(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>(reason=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> reason;</span><br><span class="line">&#125;)</span><br><span class="line">console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201122230646398.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        let data = &#x27;123&#x27;;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    p.finally(function () &#123;</span><br><span class="line">        console.log(&#x27;finally&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.<span class="built_in">log</span>(p);</span><br></pre></td></tr></table></figure>
<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>以then方法为例 使用promise封装读取多个文件的函数（会返回一个promise 这个promise对象也有一个then方法。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = require(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//使用 promise 实现链式调用</span></span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/为学.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/观书有感.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            resolve([value,data]);<span class="comment">//拿到的value是第一次的data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(&#x27;C:/Users/14828/Desktop/Task/TC/面向对象编程/resources/插秧诗.md&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">                value.push(data)<span class="comment">//此时的value是一个数组  里面放着前两个文件的data</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(value=&gt;&#123;</span><br><span class="line">        console.log(value.join(&#x27;\r\n&#x27;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
